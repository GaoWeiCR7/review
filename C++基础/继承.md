# 单继承
1. 派生类除了拥有新定义的成员外，还拥有基类的所有成员（基类的构造函数和赋值操作符重载函数除外）。
* 定义派生类时一定要见到基类的定义。
```
class A;  //声明
class B: public A  //Error
{  int z;
  public:
   void h() { g(); }  //Error，编译程序不知道基类中
				       //是否有函数g以及函数g的原型。
};
......
B b; //Error，编译无法确定b所需内存空间的大小。
```
* 如果在派生类中没有显式说明，基类的友元不是派生类的友元；如果基类是另一个类的友元，而该类没有显式说明，则派生类也不是该类的友元。
* C++中，派生类不能直接访问基类的私有成员。
* C++类向外界提供两种接口：  
public：对象的使用者（类的实例用户）  
public+protected：派生类  

2. 如果派生类中定义了与基类同名的成员，则基类的成员名在派生类的作用域内不直接可见（被隐藏，Hidden）。访问基类同名成员时要用基类名受限。例如:
```
class B: public A
{		int z;
  public:
		void f();
		void h()
		{	f();  //B类中的f
			A::f();  //A类中的f
		}
};
B b;
b.f();  //B类中的f
b.A::f();  //A类中的f 
```
* 即使派生类中定义了与基类同名但参数不同的成员函数，基类的同名函数在派生类的作用域中也是不直接可见的，可以用基类名受限方式来使用之
```
class A //基类
{		int x,y;
	public:
		void f();
		void g();
};
class B: public A
{		int z;
	public:
		void f(int); //不是重载A的f！ 
		void h() 
		{	f(1);  //OK
			f();  //Error
			A::f();  //OK
		}
};
......
B b;
b.f(1);  //OK
b.f();  //Error
b.A::f();  //OK
```
* 也可以在派生类中使用using声明把基类中某个的函数名对派生类开放：
```
class B: public A
{		int z;
	public:
		using A::f;
		void f(int); 
		void h() 
		{	f(1);  //OK
			f();  //OK，等价于A::f();
		}
};
......
B b;
b.f(1);  //OK
b.f();  //OK，等价于b.A::f();
```
3. 继承方式 
* 继承方式在定义派生类时指定：  
```
class <派生类名>：[<继承方式>] <基类名>
{	<成员说明表>
};
```
继承方式可以是：public、private和protected。  
默认的继承方式为：private。  

4. 子类型
* 对用类型T表达的所有程序P，当用类型S去替换程序P中的所有的类型T时，程序P的功能不变，则称类型S是类型T的子类型。  
在C++中，把类看作类型，把以public方式继承的派生类看作是基类的子类型。
```
class A //基类
{	  int x,y;
	public:
	  void f() { x++; y++; }
	  ......
};
class B: public A //派生类
{	  int z;
	public:
	  void g() { z++; } 
     ......
};
```
下面的操作是合法的：
```
A a;
B b;
a.f(); b.f(); //OK
a = b;  //OK，用b去改变a的状态，属于B但不属于A的
	       //数据成员（z）将被忽略。
A *p = &b;  //OK，A类指针p指向B类对象b。
......
void func1(A *p); 
void func2(A &x);
void func3(A x);
func1(&a); func2(a); func3(a); //OK
func1(&b); func2(b); func3(b); //OK
```
下面的操作是不合法的：
```
A a;
B b;
a.g(); //Error，a没有g这个成员函数。
b = a;  //Error，它将导致b有不一致的成员数据
		//（a中没有这些数据）。
B *q = &a;  //Error，“q->g();”会修改不属于a的数据！
......
void func1(B *p); 
void func2(B &x);
void func3(B x);
func1(&a); func2(a); func3(a); //Error
```
5. 派生类对象的初始化
* 派生类对象的初始化由基类和派生类共同完成：  
从基类继承的数据成员由基类的构造函数初始化；  
派生类的数据成员由派生类的构造函数初始化。  
* 当创建派生类的对象时，  
先执行基类的构造函数，再执行派生类构造函数。  
默认情况下，调用基类的默认构造函数，如果要调用基类的非默认构造函数，则必须在派生类构造函数的成员初始化表中指出。  
```
class A
{		int x;
	public:
		A() { x = 0; }
		A(int i) { x = i; }
};
class B: public A
{		int y;
	public:
		B() { y = 0; }
		B(int i) { y = i; }
		B(int i, int j):A(i) { y = j; }
};
......
B b1;  //执行A::A()和B::B()，b1.x等于0，b1.y等于0。
B b2(1);  //执行A::A()和B::B(int)，b2.x等于0，b2.y等于1。
B b3(1,2);  //执行A::A(int)和B::B(int,int)，b3.x等于1，
			//b3.y等于2。
```
* 如果一个类D既有基类B、又有成员对象类M，则  
在创建D类对象时，构造函数的执行次序为：  
B->M->D  
当D类的对象消亡时，析构函数的执行次序为：  
D->M->B  

6. 派生类拷贝构造函数
* 派生类的隐式拷贝构造函数（由编译程序提供）将会调用基类的拷贝构造函数。
* 派生类自定义的拷贝构造函数在默认情况下则调用基类的默认构造函数。需要时，可在派生类自定义拷贝构造函数的“成员初始化表”中显式地指出调用基类的拷贝构造函数。 
```
class A {	...... };
class B: public A
{		......
	public:
B() { ...... }
		B(const B& b) :A(b)  //调用A类的拷贝构造函数
		{	...... //用b对this的派生类成员进行初始化
			
		}
}; 
B b1;
B b2(b1); 
```
7. 派生类对象的赋值操作
* 派生类隐式的赋值操作除了对派生类成员进行赋值外，还将调用基类的赋值操作对基类成员进行赋值。
* 派生类自定义的赋值操作符重载函数不会自动调用基类的赋值操作，需要在自定义的赋值操作符重载函数中显式地指出。
```
class A {	...... };
class B: public A
{		......
	public:
		B& operator =(const B& b)
		{	if (&b == this) return *this;  //防止自身赋值。
			 *(A*)this = b; //调用基类的赋值操作符对基类成员
						          //进行赋值。也可写成： 
						          //this->A::operator =(b); 
			...... //对派生类的成员赋值
			return *this;
		}
}; 
......
B b1,b2;
b1 = b2;
```


