# 转移构造函数
1. 拷贝构造的问题：当用一个临时或即将消亡的对象去初始化另一个同类的对象时，目前的拷贝构造函数的实现效率有时是不高的。
```
A f()
{ A t("1234"); //创建局部对象t（调用构造函数）
   ......
   return t; //创建返回值对象，用即将消亡的对象t对其
                //初始化（调用拷贝构造函数），然后，
                //对象t消亡（调用析构函数）
}
int main()
{ ......
   f().g(); 	//使用函数f的返回值对象，
                //然后，该返回值对象消亡（调用析构函数）
   ......
}
问题：为什么不把对象t申请的空间直接带到返回值对象中呢？
```
2. 为了解决上面的问题，C++新国际标准（C++11）为C++提供了一种新的构造函数――转移构造函数（move constructor）： A(A&& x); //参数类型为右值引用类型：&&

* 当用一个临时对象或即将消亡的对象去初始化另一个对象时，  
如果对象类中有转移构造函数，则会去调用转移构造函数来对对象初始化。  
否则去调用拷贝构造函数进行对象初始化。（注意：系统不会提供隐式转移构造函数！）  
* 在转移构造函数中实现资源的转移：
```
A(A&& x) //参数类型为右值引用类型&&
{ p = x.p; //把参数对象x的p所指向的空间作为
               //新对象的p所指向的空间（资源转移）
   x.p = NULL; //使得参数对象x的p不再拥有
		          //原来所指向的空间。
}
```
```
有了上述转移构造函数之后，前面例子中的“return t;”就会去调用它来实现资源的转移！
```
# 赋值操作符重载
1. 赋值操作符重载问题:当用于赋值的对象是一个临时或即将消亡的对象时，目前的赋值操作符重载函数的实现效率有时是不高的。
```
A f(); //返回一个A类的临时对象作为返回值
int main()
{ A a="abcd";
   ......
   a = f();  //用函数f返回的临时对象去调用
                //赋值操作符重载函数，然后，
	         //临时对象消亡（调用析构函数）
   ......
}
问题：为什么在赋值时不把函数f返回值对象申请的空间直接带到对象a中来呢？
```
2. 为了解决上面的问题，C++新国际标准（C++11）允许在类中定义一个转移赋值操作符重载函数（move assignment operator）：A& operator=(A&& x) //参数类型为右值引用：&&
* 当用于赋值的对象是一个临时的或即将消亡的对象时，  
如果对象类中有转移赋值操作符重载函数，则会去调用它来实现对象的赋值。  
否则将调用普通的赋值操作符重载函数来实现对象的赋值。（注意：系统不会提供隐式的转移赋值操作符重载函数）  

* 在转移赋值操作符重载函数中实现资源的转移：
```
A& operator=(A&& x) //参数类型为右值引用
{ if (&x == this) return *this;
   delete []p; //归还老空间
   p = x.p; //使用参数对象的空间（资源转移）
   x.p = NULL; //使得参数对象不再拥有空间
   return *this; 
 }
有了上述的转移赋值操作符重载函数后，前面的“a = f();”就会调用之把函数f返回值对象申请的空间直接带到对象a中来！
```
3. 转移构造与转移赋值联合作用
```
A f()
{ A t("1234");
   ......
   return t;                 
}
int main()
{ A a="abcd";
   ......
   a = f(); 	
   ......
}
对象t中申请的空间通过转移构造函数和转移赋值操作符重载函数带到了对象a中！
```
# 函数指针
1. 声明指针时，必须指定指针指向的数据类型，同样，声明指向函数的指针时，必须指定指针指向的函数类型，这意味着声明应当指定函数的返回类型以及函数的参数列表。
```
double cal(int);   // prototype
double (*pf)(int);   // 指针pf指向的函数， 输入参数为int,返回值为double 
pf = cal;    // 指针赋值
```
2. 如果将指针作为函数的参数传递：
```
void estimate(int lines, double (*pf)(int));  // 函数指针作为参数传递 
```
3. 使用指针调用函数
```
double y = cal(5);   // 通过函数调用
double y = (*pf)(5);   // 通过指针调用 推荐的写法 
double y = pf(5);     // 这样也对， 但是不推荐这样写
```
