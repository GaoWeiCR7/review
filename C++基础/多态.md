# 多态
1. 通常体现为：  
一名多用：  
函数名重载  
操作符重载   
类属性(泛型generic programming)：  
类属函数：一个函数能对多种类型的数据进行操作。  
类属类型：一个类型可以描述多种类型的数据。  
2. 对于具有public继承关系的两个类，在C++中存在下面的多态：  
派生类对象的类型既可以是派生类，也可以是基类。（一个对象可以属于多种类型）  
基类的指针或引用可以指向或引用基类对象，也可以指向或引用派生类对象。（一个对象标识可以属于多种类型，它可以标识多种对象）  
一个可以发送到基类对象的消息，也可以发送到派生类对象，从而可能会得到不同的解释。（消息的多态）。  
3. 消息的静态绑定
```
class A
{		int x,y;
	public:
		void f();
};
class B: public A
{		int z;
	public:
   		void f(); //与A类的f是什么关系？
   		void g();
};
```
```
void func1(A& x)
{	......
	x.f(); //调用A::f还是B::f ？答案是：A::f
	......
}
void func2(A *p)
{	......
	p->f(); //调用A::f还是B::f ？答案是：A::f
	......
}
......
A a;
func1(a);
func2(&a);
B b;
func1(b);
func2(&b);
```
4. 消息的动态绑定
* 一般情况下，需要在func1（或func2）中根据x（或p）实际引用（或指向）的对象来决定是调用A::f还是B::f，即采用动态绑定。
* 在C++中用虚函数来实现动态绑定。
```
class A
{		int x,y;
	public:
		virtual void f(); //虚函数
};
class B: public A
{		int z;
	public:
   		void f(); //与A类的f是什么关系？
   		void g();
};
```
```
void func1(A& x)
{	......
	x.f(); //调用A::f还是B::f ？答案是：A::f或B::f
	......
}
void func2(A *p)
{	......
	p->f(); //调用A::f还是B::f ？答案是：A::f或B::f
	......
}
......
A a;
func1(a); //在func1中调用A::f
func2(&a); //在func2中调用A::f
B b;
func1(b); //在func1中调用B::f
func2(&b); //在func2中调用B::f
```
5. 对于基类中的一个虚函数，在派生类中定义的、与之具有相同型构的成员函数是对基类该成员函数的重定义（或称覆盖，override）。  
* 相同的型构是指：
派生类中定义的成员函数的名字、参数个数和类型与基类相应成员函数相同；  
其返回值类型与基类成员函数返回值类型或者相同，或者是基类成员函数返回值类型的public派生类。  
6. 基类的构造函数、析构函数中对虚函数的调用不进行动态绑定。
* 原因：理论上讲，派生类的虚函数可能会用到派生类里多出来的成员变量，而这些成员变量在最开始执行基类的构造函数时还没有被分配资源初始化，为了杜绝这种危险操作所以C++选择执行基类的虚函数。  
更底层的原因在于，在第一阶段执行基类构造函数的时候，buy在运行时(runtime)里的类型信息本来就是被标记为基类的类型Transaction的。只有到第二阶段执行派生类BuyTransaction的构造函数时，buy实例才成为BuyTransaction类型。
7. 构造函数不可能定义为虚函数
* 原因：虚函数的调用需要 vptr 指针，而该指针存放在对象的内容空间中，需要调用构造函数才可以创建它的值，否则即使开辟了空间，该 vptr 指针为随机值；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有 vptr 地址用来调用虚函数之一的构造函数了。    
虚函数主要是实现多态，在运行时才可以明确调用对象，根据传入的对象类型来调用函数，例如通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用。那使用虚函数也没有实际意义。
8. 析构函数可以（往往）是虚函数。
```
class A
{  ......
  public:
	A() { f();}
	~A();
	virtual void f();
	void g();
	void h() { f(); g(); }
};
class B: public A
{  .......
 public:
   B() { ...... }
	~B();
	void f(); 
	void g(); 
};
```
```
A a;  //调用A::A()和A::f
a.f();  //调用A::f
a.g();  //调用A::g
a.h();  //调用A::h、A::f和A::g
//a消亡时会调用A::~A()

B b;  //调用B::B(), A::A()和A::f
b.f();  //调用B::f
b.g();  //调用B::g
b.h();  //调用A::h、B::f和A::g
//b消亡时会调用B::~B()和A::~A()
```
```
A *p;
p = &a;
p->f();  //调用A::f
p->g();  //调用A::g
p->h();  //调用A::h, A::f和A::g
p = &b;
p->f();  //调用B::f
p->A::f(); //调用A::f
p->g();  //调用A::g，非虚函数采用静态绑定
p->h();  //调用A::h, B::f和A::g
p = new A;  //调用A::A()和A::f
.......
delete p;  //调用A::~A()
p = new B;  //调用B::B(), A::A()和A::f
.......
delete p;  //只调用A::~A()，不调用B:~B()
               //为什么？
                 //没有把A的析构函数定义为虚函数！
```
9. 通过基类指针访问派生类中新定义的成员
```
class A
{	      .......
   public:
		virtual void f();
};
class B: public A
{	      ......
    public:
		void f(); 
		void g(); 
};
A *p=new B;
......
p->f(); //OK
p->g(); //Error
((B *)p)->g(); //OK，不安全！

//需要运行时刻的类型信息（RTTI）支持
B *q=dynamic_cast<B *>(p);
if (q != NULL) q->g();
```
10. 纯虚函数:纯虚函数是没给出实现的虚函数，函数体用“=0”表示， 例如：
```
class A
{	......
	public:
		virtual int f()=0; //纯虚函数
	......
};
```
11. 抽象类:包含纯虚函数的类称为抽象类。
* 抽象类不能用于创建对象。 例如:
```
class A //抽象类
{	......
	public:
		virtual int f()=0; //纯虚函数
	......
};
......
A a;  //Error，A是抽象类
```

