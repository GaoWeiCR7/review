# OOP的设计模式的五项原则
1. 单一职责原则 ：避免相同的职责分散到不同的类中，另一个是避免一个类承担太多职责。减少类的耦合，提高类的复用性
2. 开放-封闭原则：软件实体应当对扩展开放，对修改关闭 
3. 里氏替换原则 ：子类型必须能够替换掉他们的父类型、并出现在父类能够出现的任何地方。
+ 子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。
+ 子类中可以增加自己特有的方法。
+ 当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
+ 当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。
4. 依赖倒置原则 
* 上层模块不应该依赖于下层模块，他们共同依赖于一个抽象，即：父类不能依赖子类，他们都要依赖抽象类。
* 抽象不能依赖于具体，具体应该要依赖于抽象。
5. 接口隔离原则 ：表明客户端不应该被强迫实现一些他们不会使用的接口，应该把胖接口中额方法分组，然后用多个接口代替它，每个接口服务于一个子模块。简单说，就是使用多个专门的接口比使用单个接口好很多。
+ 一个类对另外一个类的依赖性应当是建立在最小的接口上
+ 客户端程序不应该依赖它不需要的接口方法。
6. 合成/聚合复用原则 ：优先使用对象组合，而不是继承来达到复用的目的
7. 迪米特法则：每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位

# 常见设计模式
* 单例模式：单例模式主要解决一个全局使用的类频繁的创建和销毁的问题。单例模式下可以确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。单例模式有三个要素：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。
* 工厂模式：工厂模式主要解决接口选择的问题。该模式下定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使其创建过程延迟到子类进行。
* 观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
* 装饰器模式：对已经存在的某些类进行装饰，以此来扩展一些功能，从而动态的为一个对象增加新的功能。装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。

# 如何保证单例模式只有唯一实例
1. 将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；

2. 在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。

3. C++的实现有两种，一种通过局部静态变量，利用其只初始化一次的特点，返回对象。另外一种，则是定义全局的指针，getInstance判断该指针是否为空，为空时才实例化对象

# 单例模式
* 优点：
1. 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。
2. 避免对资源的多重占用（比如写文件操作）。

* 缺点：
1. 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

* 使用场景：
1. 要求生产唯一序列号。 
2. WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。 
3. 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。

