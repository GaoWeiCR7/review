# OSI七层模型和TCP/IP四层模型及相应协议
* OSI七层模型
1. 物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45
2. 数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP
3. 网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP
4. 传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP
5. 会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS
6. 表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII
7. 应用层: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS  
注意：ARP很多书中也将其归为数据链路层

* TCP/IP四层模型
1. 网络接口层：MAC VLAN
2. 网络层:IP ARP ICMP
3. 传输层:TCP UDP
4. 应用层:HTTP DNS SMTP

# TCP怎么保证可靠性，TCP建立连接和断开连接的过程
* TCP保证可靠性：
1. 序列号、确认应答、超时重传  
数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送方迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。
2. 窗口控制与高速重发控制/快速重传（重复确认应答）  
TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。  
使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒......
3. 拥塞控制  
拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口——cwnd。
+ 1. 慢启动  
最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢启动阈值，则使用拥塞避免算法，避免cwnd增长过大。
  2. 拥塞避免
每经过一个往返时间RTT，cwnd就增长1。  
在慢启动和拥塞避免的过程中，一旦发现网络拥塞，就把慢启动阈值设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）
  3. 快重传
接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。
  4. 快恢复
当发送方连续收到了三个重复确认，就乘法减半（慢启动阈值减半），将当前的cwnd设置为慢启动阈值，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。  
采用快恢复算法时，慢启动只在建立连接和网络超时才使用。
+ 采用慢开始和拥塞避免算法的时候
1. 一旦cwnd>慢启动阈值，就采用拥塞避免算法，减慢增长速度
2. 一旦出现丢包的情况，就重新进行慢启动，减慢增长速度
+ 采用快恢复和快重传算法的时候
1. 一旦cwnd>慢启动阈值，就采用拥塞避免算法，减慢增长速度
2. 一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度

# TCP三次握手和四次挥手
* 三次握手：
1. Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
2. Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
3. Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。
* 四次挥手：
1. 数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。
2. 服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。
3. 当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认
4. 客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。

    ![](tcp.png)

* 为什么要三次握手
1. 资源浪费：如果客户端的SYN阻塞了，重复发送多次SYN报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。
2. 可靠性
3. 初始序列号：三次握手的本质是为了同步双方的初始序列号：确定两个双向的初始序列号，TCP用序列号来编址传输的字节，由于是两个方向的连接，所以需要两个序列号，握手过程不传输任何字节，仅仅确定初始序列号。
* 三次挥手最重要的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。

# HTTP和HTTPS的区别，HTTPS优缺点
* 区别
1. HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性
2. HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥
3. HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书
4. HTTP协议端口是80，HTTPS协议端口是443

* HTTPS优点：
1. HTTPS传输数据过程中使用密钥进行加密，所以安全性更高
2. HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器

* HTTPS缺点：
1. HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加
2. HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高

# HTTP返回码
HTTP协议的响应报文由状态行、响应头部和响应包体组成，其响应状态码总体描述如下：  
1xx：指示信息--表示请求已接收，继续处理。

2xx：成功--表示请求已被成功接收、理解、接受。

3xx：重定向--要完成请求必须进行更进一步的操作。

4xx：客户端错误--请求有语法错误或请求无法实现。

5xx：服务器端错误--服务器未能实现合法的请求。

常见状态代码、状态描述的详细说明如下：  
200 OK：客户端请求成功。

206 partial content服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围

300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个。

301  moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。

302 move temporarily(临时重定向)：请求的资源现在临时从不同的URI中获得，

304：not modified :如果客户端发送一个待条件的GET请求并且该请求以经被允许，而文档内容未被改变，则返回304,该响应不包含包体（即可直接使用缓存）。

403 Forbidden：服务器收到请求，但是拒绝提供服务。

t Found：请求资源不存在，举个例子：输入了错误的URL。

# IP地址作用，以及MAC地址作用
MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。而IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。

# 操作系统中的中断分类
1. 由CPU外部引起的，如I/O中断、时钟中断
2. 来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，地址越界、浮点溢出
3. 在程序中使用了系统调用  

中断响应由硬件实施，中断处理主要由软件实施

# TCP/IP数据链路层的交互过程
数据包到达网络等准备往数据链路层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找该目标ip的mac地址，如果查到了，就将目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器

# 传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文
根据端口区分；  
看ip头中的协议标识字段，17是udp，6是tcp

# TCP和UDP的区别和各自适用的场景
* TCP和UDP区别
1. 连接  
TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。  
UDP无连接。  

2. 服务对象  
TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；  
UDP支持一对一，一对多，多对一，多对多的交互通信。

3. 可靠性  
TCP是可靠交付：无差错，不丢失，不重复，按序到达。  
UDP是尽最大努力交付，不保证可靠交付。

4. 拥塞控制，流量控制  
TCP有拥塞控制和流量控制保证数据传输的安全性。  
UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。

5. 报文长度  
TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。
UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。  

6. 首部开销  
TCP首部开销大，首部20个字节。  
UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）
* TCP和UDP适用场景  
从特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。  
若通信数据完整性大于通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。

