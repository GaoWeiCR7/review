# OSI七层模型和TCP/IP四层模型及相应协议
* OSI七层模型
1. 物理层: 通过媒介传输比特,确定机械及电气规范,传输单位为bit，主要包括的协议为：IEE802.3 CLOCK RJ45
2. 数据链路层: 将比特组装成帧和点到点的传递,传输单位为帧,主要包括的协议为MAC VLAN PPP
3. 网络层：负责数据包从源到宿的传递和网际互连，传输单位为包,主要包括的协议为IP ARP ICMP
4. 传输层：提供端到端的可靠报文传递和错误恢复，传输单位为报文,主要包括的协议为TCP UDP
5. 会话层：建立、管理和终止会话，传输单位为SPDU，主要包括的协议为RPC NFS
6. 表示层: 对数据进行翻译、加密和压缩,传输单位为PPDU，主要包括的协议为JPEG ASII
7. 应用层: 允许访问OSI环境的手段,传输单位为APDU，主要包括的协议为FTP HTTP DNS  
注意：ARP很多书中也将其归为数据链路层

* TCP/IP四层模型
1. 网络接口层：MAC VLAN
2. 网络层:IP ARP ICMP
3. 传输层:TCP UDP
4. 应用层:HTTP DNS SMTP

# TCP怎么保证可靠性，TCP建立连接和断开连接的过程
* TCP保证可靠性：
1. 序列号、确认应答、超时重传  
数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送方迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。
2. 窗口控制与高速重发控制/快速重传（重复确认应答）  
TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。  
使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒......
3. 拥塞控制  
拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口——cwnd。
+ 1. 慢启动  
最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢启动阈值，则使用拥塞避免算法，避免cwnd增长过大。
  2. 拥塞避免
每经过一个往返时间RTT，cwnd就增长1。  
在慢启动和拥塞避免的过程中，一旦发现网络拥塞，就把慢启动阈值设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）
  3. 快重传
接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。
  4. 快恢复
当发送方连续收到了三个重复确认，就乘法减半（慢启动阈值减半），将当前的cwnd设置为慢启动阈值，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。  
采用快恢复算法时，慢启动只在建立连接和网络超时才使用。
+ 采用慢开始和拥塞避免算法的时候
1. 一旦cwnd>慢启动阈值，就采用拥塞避免算法，减慢增长速度
2. 一旦出现丢包的情况，就重新进行慢启动，减慢增长速度
+ 采用快恢复和快重传算法的时候
1. 一旦cwnd>慢启动阈值，就采用拥塞避免算法，减慢增长速度
2. 一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度

# TCP三次握手和四次挥手
* 三次握手：
1. Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
2. Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
3. Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。
* 四次挥手：
1. 数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。
2. 服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。
3. 当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认
4. 客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接。

* 2MSL意义
1. 保证最后一次握手报文能到B，能进行超时重传。
2. 2MSL后，这次连接的所有报文都会消失，不会影响下一次连接。
    ![](https://github.com/GaoWeiCR7/review/blob/master/%E8%AE%A1%E7%BD%91/tcp.png)

* 为什么要三次握手
1. 资源浪费：如果客户端的SYN阻塞了，重复发送多次SYN报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。
2. 可靠性
3. 初始序列号：三次握手的本质是为了同步双方的初始序列号：确定两个双向的初始序列号，TCP用序列号来编址传输的字节，由于是两个方向的连接，所以需要两个序列号，握手过程不传输任何字节，仅仅确定初始序列号。
* 三次握手最重要的目的是连接服务器指定端口，建立TCP连接,并同步连接双方的序列号和确认号并交换 TCP 窗口大小信息。

# http协议
* HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web）服务器传输超文本到本地浏览器的传送协议。
1. HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件，图片文件，查询结果等）。
2. HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。
3. HTTP协议工作于客户端-服务端架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。
* HTTP协议特点
1. 简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。
2. 灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
3. 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
4. 无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
5. 支持B/S及C/S模式。
6. 默认端口80
7. 基于TCP协议
* HTTP 请求/响应的步骤如下
1. 客户端连接到Web服务器
2. 发送HTTP请求
3. 服务器接受请求并返回HTTP响应
4. 释放连接TCP连接
5. 客户端浏览器解析HTML内容
+ for example:在浏览器地址栏键入URL，按下回车之后会经历以下流程：
1. 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；
2. 解析出 IP 地址后，根据该 IP 地址和默认端口80，和服务器建立TCP连接；
3. 浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器；
4. 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；
5. 释放 TCP连接；
6. 浏览器将该 html 文本并显示内容；


# HTTP和HTTPS的区别，HTTPS优缺点
* 区别
1. HTTP协议是以明文的方式在网络中传输数据，而HTTPS协议传输的数据则是经过TLS加密后的，HTTPS具有更高的安全性
2. HTTPS在TCP三次握手阶段之后，还需要进行SSL 的handshake，协商加密使用的对称加密密钥
3. HTTPS协议需要服务端申请证书，浏览器端安装对应的根证书
4. HTTP协议端口是80，HTTPS协议端口是443

* HTTPS优点：
1. HTTPS传输数据过程中使用密钥进行加密，所以安全性更高
2. HTTPS协议可以认证用户和服务器，确保数据发送到正确的用户和服务器

* HTTPS缺点：
1. HTTPS握手阶段延时较高：由于在进行HTTP会话之前还需要进行SSL握手，因此HTTPS协议握手阶段延时增加
2. HTTPS部署成本高：一方面HTTPS协议需要使用证书来验证自身的安全性，所以需要购买CA证书；另一方面由于采用HTTPS协议需要进行加解密的计算，占用CPU资源较多，需要的服务器配置或数目高

# HTTP返回码
HTTP协议的响应报文由状态行、响应头部和响应包体组成，其响应状态码总体描述如下：  
1xx：指示信息--表示请求已接收，继续处理。

2xx：成功--表示请求已被成功接收、理解、接受。

3xx：重定向--要完成请求必须进行更进一步的操作。

4xx：客户端错误--请求有语法错误或请求无法实现。

5xx：服务器端错误--服务器未能实现合法的请求。

常见状态代码、状态描述的详细说明如下：  
200 OK：客户端请求成功。

206 partial content服务器已经正确处理部分GET请求，实现断点续传或同时分片下载，该请求必须包含Range请求头来指示客户端期望得到的范围

300 multiple choices（可选重定向）:被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个。

301  moved permanently（永久重定向）：该资源已被永久移动到新位置，将来任何对该资源的访问都要使用本响应返回的若干个URI之一。

302 move temporarily(临时重定向)：请求的资源现在临时从不同的URI中获得，

304：not modified :如果客户端发送一个待条件的GET请求并且该请求以经被允许，而文档内容未被改变，则返回304,该响应不包含包体（即可直接使用缓存）。

403 Forbidden：服务器收到请求，但是拒绝提供服务。

t Found：请求资源不存在，举个例子：输入了错误的URL。

# IP地址作用，以及MAC地址作用
MAC地址是一个硬件地址，用来定义网络设备的位置，主要由数据链路层负责。而IP地址是IP协议提供的一种统一的地址格式，为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。

# 操作系统中的中断分类
1. 由CPU外部引起的，如I/O中断、时钟中断
2. 来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，地址越界、浮点溢出
3. 在程序中使用了系统调用  

中断响应由硬件实施，中断处理主要由软件实施

# TCP/IP数据链路层的交互过程
数据包到达网络等准备往数据链路层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找该目标ip的mac地址，如果查到了，就将目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器

# 传递到IP层怎么知道报文该给哪个应用程序，它怎么区分UDP报文还是TCP报文
根据端口区分；  
看ip头中的协议标识字段，17是udp，6是tcp

# TCP和UDP的区别和各自适用的场景
* TCP和UDP区别
1. 连接  
TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接。  
UDP无连接。  

2. 服务对象  
TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；  
UDP支持一对一，一对多，多对一，多对多的交互通信。

3. 可靠性  
TCP是可靠交付：无差错，不丢失，不重复，按序到达。  
UDP是尽最大努力交付，不保证可靠交付。

4. 拥塞控制，流量控制  
TCP有拥塞控制和流量控制保证数据传输的安全性。  
UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。

5. 报文长度  
TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的。
UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。  

6. 首部开销  
TCP首部开销大，首部20个字节。  
UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）
* TCP和UDP适用场景  
从特点上我们已经知道，TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。  
若通信数据完整性大于通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。

# GET和POST的区别
* 概括  
1. 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；  
2. 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）

* 区别：
1. get参数通过url传递，post放在request body中。
2. get请求在url中传递的参数是有长度限制的，而post没有。
3. get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。
4. get请求只能进行url编码，而post支持多种编码方式。
5. get请求会浏览器主动cache，而post支持多种编码方式。
6. get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。
7. GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
8. GET产生一个TCP数据包；POST产生两个TCP数据包。

# socket编程中服务器端和客户端主要用到哪些函数
* 基于TCP的socket：
  + 服务器
  1. 创建一个socket，用函数socket()
  2. 绑定IP地址、端口等信息到socket上，用函数bind()
  3. 设置允许的最大连接数，用函数listen()
  4. 接收客户端上来的连接，用函数accept()
  5. 收发数据，用函数send()和recv()，或者read()和write()
  6. 关闭网络连接
  + 客户端
  1. 创建一个socket，用函数socket()
  2. 设置要连接的对方的IP地址和端口等属性
  3. 连接服务器，用函数connect()
  4. 收发数据，用函数send()和recv()，或read()和write()
  5. 关闭网络连接
* 基于UDP的socket：
  + 服务器端
  1. 建立套接字文件描述符，使用函数socket()，生成套接字文件描述符。
  2. 设置服务器地址和侦听端口，初始化要绑定的网络地址结构。
  3. 绑定侦听端口，使用bind()函数，将套接字文件描述符和一个地址类型变量进行绑定。
  4. 接收客户端的数据，使用recvfrom()函数接收客户端的网络数据。
  5. 向客户端发送数据，使用sendto()函数向服务器主机发送数据。
  6. 关闭套接字，使用close()函数释放资源。
  + 客户端
  1. 建立套接字文件描述符，socket()。
  2. 设置服务器地址和端口，struct sockaddr。
  3. 向服务器发送数据，sendto()。
  4. 接收服务器的数据，recvfrom()。
  5. 关闭套接字，close()。

# 数字证书
* 数字证书在一个身份和该身份的持有者所拥有的公/私钥对之间建立了一种联系，由认证中心（CA）或者认证中心的下级认证中心颁发的。
* 数字证书颁发过程如下：用户产生了自己的密钥对，并将公共密钥及部分个人身份信息传送给一家认证中心。认证中心在核实身份后，将执行一些必要的步骤，以确信请求确实由用户发送而来，然后，认证中心将发给用户一个数字证书，该证书内附了用户和他的密钥等信息，同时还附有对认证中心公共密钥加以确认的数字证书。当用户想证明其公开密钥的合法性时，就可以提供这一数字证书。
* 内容：
1. 证书的版本信息；
2. 证书的序列号，每个证书都有一个唯一的证书序列号；
3. 证书所使用的签名算法；
4. 证书的发行机构名称，命名规则一般采用X.500格式；
5. 证书的有效期，通用的证书一般采用UTC时间格式；
6. 证书所有人的名称，命名规则一般采用X.500格式；
7. 证书所有人的公开密钥；
8. 证书发行者对证书的签名。

# udp的connect函数
* 一旦UDP套接字调用了connect系统调用，那么这个UDP上的连接就变成一对一的连接，但是通过这个UDP连接传输数据的性质还是不变的，仍然是不可靠的UDP连接。一旦变成一对一的连接，在调用系统调用发送和接受数据时也就可以使用TCP那一套系统调用了。
1. 我们再也不能给输出操作指定目的IP地址和端口号。也就是说，我们不使用sendto，而改用write或send。写到已连接UDP套接字上的任何内容都自动发送到由connect指定的协议地址。可以给已连接的UDP套接字调用sendto，但是不能指定目的地址。sendto的第五个参数必须为空指针，第六个参数应该为0.
2. 不必使用recvfrom以获悉数据报的发送者，而改用read、recv或recvmsg。在一个已连接UDP套接字上，由内核为输入操作返回的数据报只有那些来自connect指定协议地址的数据报。这样就限制一个已连接UDP套接字能且仅能与一个对端交换数据报。
3. 由已连接UDP套接字引发的异步错误会返回给它们所在的进程，而未连接的UDP套接字不接收任何异步错误。
* UDP客户进程或服务器进程只在使用自己的UDP套接字与确定的唯一对端进行通信时，才可以调用connect。调用connect的通常是UDP客户，不过有些网络应用中的UDP服务器会与单个客户长时间通信TFTP，这种情况下，客户和服务器都可能调用connect。

# 阻塞，非阻塞，同步，异步
* 阻塞：调用者在事件没有发生的时候，一直在等待事件发生，不能去处理别的任务
* 非阻塞：调用者在事件没有发生的时候，可以去处理别的任务
* 同步：调用者必须循环自去查看事件有没有发生
* 异步：调用者不用自己去查看事件有没有发生，而是等待着注册在事件上的回调函数通知自己

# 搜索baidu，会用到计算机网络中的什么层？每层是干什么的
* 浏览器中输入URL  
浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。DNS服务器是基于UDP的，因此会用到UDP协议。  
得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议，http协议报文格式上面已经提到。http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。如果采用https还会使用https协议先对http数据进行加密。TCP层如果有需要先将HTTP数据包分片，分片依据路径MTU和MSS。TCP的数据包然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。

1. DNS协议，http协议，https协议属于应用层
* 应用层是体系结构中的最高层。应用层确定进程之间通信的性质以满足用户的需要。这里的进程就是指正在运行的程序。应用层不仅要提供应用进程所需要的信息交换和远地操作，而且还要作为互相作用的应用进程的用户代理，来完成一些为进行语义上有意义的信息交换所必须的功能。应用层直接为用户的应用进程提供服务。

2. TCP/UDP属于传输层
* 传输层的任务就是负责主机中两个进程之间的通信。因特网的传输层可使用两种不同协议：即面向连接的传输控制协议TCP，和无连接的用户数据报协议UDP。面向连接的服务能够提供可靠的交付，但无连接服务则不保证提供可靠的交付，它只是“尽最大努力交付”。这两种服务方式都很有用，备有其优缺点。

3. IP协议，ARP协议属于网络层
* 网络层负责为分组交换网上的不同主机提供通信。在发送数据时，网络层将运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，分组也叫作IP数据报，或简称为数据报。网络层的另一个任务就是要选择合适的路由，使源主机运输层所传下来的分组能够交付到目的主机。

4. 数据链路层
* 当发送数据时，数据链路层的任务是将在网络层交下来的IP数据报组装成帧，在两个相邻结点间的链路上传送以帧为单位的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制、以及流量控制信息等）。控制信息使接收端能够知道—个帧从哪个比特开始和到哪个比特结束。控制信息还使接收端能够检测到所收到的帧中有无差错。

5. 物理层
* 物理层的任务就是透明地传送比特流。在物理层上所传数据的单位是比特。传递信息所利用的一些物理媒体，如双绞线、同轴电缆、光缆等，并不在物理层之内而是在物理层的下面。因此也有人把物理媒体当做第0层。

